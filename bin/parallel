#!/usr/bin/env python

import os
import sys
import copy
import time
import random
import signal
import subprocess
import multiprocessing as m
import xml.etree.ElementTree as ET

path = os.path.dirname(os.path.realpath(__file__))  + '/..'
sys.path.insert(0, path)

import common.imports.utils as u
import common.imports.constants as c

totalthreads = 0
groupthreads = 0
runnable1 = {}

def group_exec_completed(app_statfile_list):

	for app in app_statfile_list:
		if app[0].poll() == 0:
			app[1].close()
			app_statfile_list.pop(app_statfile_list.index(app))
		else:
			return False
	return True	

def group_exec_completed1(app_statfile_list, runnable):

	u.loginfo("In Group Exec Completed1")
	global totalthreads, groupthreads, runnable1


	i = 0
	while len(app_statfile_list) > 0:
		app = app_statfile_list[i]
		i += 1
		if app[0].poll() == 0:
			i -= 1
			app[1].close()
			app_statfile_list.pop(app_statfile_list.index(app))
			appid = app[2]
			u.loginfo("App Completed whose ID is: " + str(appid))
			threads = app[3]
			u.loginfo("Number of threads Freed: " + str(threads))
			u.loginfo("Searching for new set of applications to execute")
			groupthreads -= threads
			runnableb = copy.deepcopy(runnable)
			while (len(runnableb) > 0) and (groupthreads <= totalthreads):
				timestamp = u.gettimestamp().replace(' ', '_')
				appid = random.choice(runnableb)
				tree1 = ET.parse(c.PARALLEL_APP_INSTANCE_DIR + '/' + appid + '.xml')
				root1 = tree1.getroot()
				appthreads = int(root1.findall('THREADS')[0].text)
				if ((groupthreads + appthreads) <= totalthreads):
					u.loginfo("New Application Found")
					runnable.remove(appid)
					groupthreads += appthreads
					statfile = open(c.PARALLEL_STATS_DIR + '/R/' + str(appid) + '_' + timestamp + '.stat','a')
					statfile.write(runnable1[appid])
					u.loginfo('Executing perf stat ' + runnable1[appid])
					status = subprocess.Popen('perf stat ' + runnable1[appid], shell=True, stdout=statfile, stderr=statfile)
					app_statfile_list.append([status, statfile, appid, appthreads])
				runnableb.remove(appid)
		else:
			return False
	return True	

def get_group_map(runnablemap):
	groupmap = {}
	for grp in os.listdir(c.PARALLEL_GROUPS_DIR):
			tree = ET.parse(c.PARALLEL_GROUPS_DIR + '/' + grp)
			root = tree.getroot()
			groupmap.update({root.get('ID'): []})
			for app in root.getchildren():
				groupmap[root.get('ID')].append(app.text)
	return groupmap

def get_runnable_instance_map():
	runnable_instance_map = {}
	for instance in os.listdir(c.PARALLEL_APP_INSTANCE_DIR):
		runnable_instance_map.update(u.getidcmdpairbyxml(c.PARALLEL_APP_INSTANCE_DIR + '/' + instance))
	return runnable_instance_map

def main():

	global totalthreads, groupthreads, runnable1
	if os.path.isdir(c.PARALLEL_STATS_DIR):
		os.rename(c.PARALLEL_STATS_DIR, c.PARALLEL_STATS_DIR + '.' + u.gettimestamp().replace(' ', '_'))
	os.mkdir(c.PARALLEL_STATS_DIR)

	signal.signal(signal.SIGCHLD, signal.SIG_IGN) 
	runnable1 = get_runnable_instance_map()
	runnable = runnable1.keys()

	if (sys.argv[1] == '-r') or (sys.argv[1] == '--random'):
		tree = ET.parse(c.PARALLEL_RANDOM_DIR + '/R.xml')
		root = tree.getroot()
		maxthreads = root.findall('MAXTHREADS')
		overcommitfactor = root.findall('TOVERCOMMIT')

		if ((len(maxthreads) > 0) and (len(overcommitfactor) > 0)):
			totalthreads = random.choice([float(maxthreads[0].text), float(overcommitfactor[0].text) * float(m.cpu_count())])
		elif (len(maxthreads) > 0):
			u.loginfo("No Overcommitment Specified. MAXTHREADS")
			totalthreads = float(maxthreads[0].text)
		elif (len(overcommitfactor) > 0):
			u.loginfo("No Maxthread Specified.")
			totalthreads = float(overcommitfactor[0].text) * float(m.cpu_count())

		if (int(totalthreads) == 0):
			u.loginfo('zero threads')
			sys.exit(0)

		totalthreads = int(totalthreads)

		u.loginfo("Total Threads Selected: " + str(totalthreads))
	
		app_statfile_list = []
		os.mkdir(c.PARALLEL_STATS_DIR + '/R')
		runnablea = copy.deepcopy(runnable)
		u.loginfo("Runnable: " + str(runnable))
		while (len(runnablea) > 0) and (groupthreads <= totalthreads):
			timestamp = u.gettimestamp().replace(' ', '_')
			u.loginfo("Runnablea: " + str(runnablea))
			appid = random.choice(runnablea)
			tree1 = ET.parse(c.PARALLEL_APP_INSTANCE_DIR + '/' + appid + '.xml')
			root1 = tree1.getroot()
			appthreads = int(root1.findall('THREADS')[0].text)
			if ((groupthreads + appthreads) <= totalthreads):
				runnable.remove(appid)
				groupthreads += appthreads
				statfile = open(c.PARALLEL_STATS_DIR + '/R/' + str(appid) + '_' + timestamp + '.stat','a')
				statfile.write(runnable1[appid])
				u.loginfo('Executing: perf stat ' + runnable1[appid])
				status = subprocess.Popen('perf stat ' + runnable1[appid], shell=True, stdout=statfile, stderr=statfile)
				app_statfile_list.append([status, statfile, appid, appthreads])
			runnablea.remove(appid)
		
		u.loginfo("First Batch Submitted\n")
		
		while True:
			if group_exec_completed1(app_statfile_list, runnable):
				break
			else:
				u.loginfo('sleeping for jobs to finish')
				time.sleep(60)
				u.loginfo('woken up. checking if jobs are finished')

		if groupthreads != 0:
			u.logwarn("Group Threads Not ZERO at end: " + str(groupthreads))

	elif (sys.argv[1] == '-d') or (sys.argv[1] == '--defined'):

		groupmap = get_group_map(copy.deepcopy(runnable1))

		for groupid in groupmap.keys():
			app_statfile_list = []
			timestamp = u.gettimestamp().replace(' ', '_')
			u.loginfo('Executing group ' + groupid)
			os.mkdir(c.PARALLEL_STATS_DIR + '/' + groupid)
		
			for appid in groupmap[groupid]:
				u.loginfo('Executing app ' + runnable1[appid])
				statfile = open(c.PARALLEL_STATS_DIR + '/' + groupid + '/' + str(appid) + '_' + timestamp + '.stat','a')
				statfile.write(runnable1[appid])
				u.loginfo('perf stat ' + runnable1[appid])
				status = subprocess.Popen('perf stat ' + runnable1[appid], shell=True, stdout=statfile, stderr=statfile)
				app_statfile_list.append([status, statfile])
			while True:
				if group_exec_completed(app_statfile_list):
					break
				else:
					u.loginfo('sleeping for jobs to finish')
					time.sleep(10)
					u.loginfo('woken up. checking if jobs are finished')
				

if __name__ == "__main__":
	c.LOGGER = 'parallel.log'
	u.loginfo('Begin Time:  ' + u.gettimestamp())
	main()
	u.loginfo('End Time:  ' + u.gettimestamp())
