#!/usr/bin/env python

import os
import sys
import copy
import time
import random
import signal
import subprocess
import multiprocessing as m
import xml.etree.ElementTree as ET

path = os.path.dirname(os.path.realpath(__file__))  + '/..'
sys.path.insert(0, path)

import common.imports.utils as u
import common.imports.constants as c

def group_exec_completed(app_statfile_list):

	for app in app_statfile_list:
		try:
			os.kill(app[0], 0)
		except OSError:
			app[1].close()
			app_statfile_list.pop(app_statfile_list.index(app))
			pass
		return False

	return True	

def get_group_map(runnablemap):
	groupmap = {}
	if (sys.argv[1] == '-r') or (sys.argv[1] == '--random'):
		for grp in os.listdir(c.PARALLEL_RANDOM_DIR):
			tree = ET.parse(c.PARALLEL_RANDOM_DIR + '/' + grp)
			root = tree.getroot()
			groupmap.update({root.get('ID'): []})
			maxthreads = root.findall('MAXTHREADS')
			overcommitfactor = root.findall('TOVERCOMMIT')
			totalthreads = 0

			if ((len(maxthreads) > 0) and (len(overcommitfactor) > 0)):
				totalthreads = random.choice([float(maxthreads[0].text), float(overcommitfactor[0].text) * float(m.cpu_count())])
			elif (len(maxthreads) > 0):
				totalthreads = float(maxthreads[0].text)
			elif (len(overcommitfactor) > 0):
				totalthreads = float(overcommitfactor[0].text) * float(m.cpu_count())

			if (int(totalthreads) == 0):
				u.loginfo('zero threads')
				sys.exit(0)

			totalthreads = int(totalthreads)
			
			app_thread_list = []

			while ((totalthreads >= 0) and (len(runnablemap) > 0)):
				appid = random.choice(runnablemap.keys())
				tree1 = ET.parse(c.PARALLEL_APP_INSTANCE_DIR + '/' + appid + '.xml')
				root1 = tree1.getroot()
				appthreads = int(root1.findall('THREADS')[0].text)
				totalthreads -= appthreads
				runnablemap.pop(appid)
				app_thread_list.append([appid, appthreads])
				
			if totalthreads < 0:
				#applist = groupmap[root.get('ID')]
				toberemoved = -1
				distance = 100000000
				for app in app_thread_list:
					if ((totalthreads + app[1]) < distance) and ((totalthreads + app[1]) >= 0):
						distance = totalthreads + app[1]
						toberemoved = app_thread_list.index(app)

				app_thread_list.pop(toberemoved)

			for app in app_thread_list:
				groupmap[root.get('ID')].append(app[0])
	

	elif (sys.argv[1] == '-d') or (sys.argv[1] == '--defined'):
		for grp in os.listdir(c.PARALLEL_GROUPS_DIR):
			tree = ET.parse(c.PARALLEL_GROUPS_DIR + '/' + grp)
			root = tree.getroot()
			groupmap.update({root.get('ID'): []})
			for app in root.getchildren():
				groupmap[root.get('ID')].append(app.text)
	return groupmap

def get_runnable_instance_map():
	runnable_instance_map = {}
	for instance in os.listdir(c.PARALLEL_APP_INSTANCE_DIR):
		runnable_instance_map.update(u.getidcmdpairbyxml(c.PARALLEL_APP_INSTANCE_DIR + '/' + instance))
	return runnable_instance_map

def main():
	signal.signal(signal.SIGCHLD, signal.SIG_IGN)
	runnable = get_runnable_instance_map()
	groupmap = get_group_map(copy.deepcopy(runnable))
	if os.path.isdir(c.PARALLEL_STATS_DIR):
		os.rename(c.PARALLEL_STATS_DIR, c.PARALLEL_STATS_DIR + '.' + u.gettimestamp().replace(' ', '_'))

	os.mkdir(c.PARALLEL_STATS_DIR)
	for groupid in groupmap.keys():
		app_statfile_list = []
		timestamp = u.gettimestamp().replace(' ', '_')
		u.loginfo('Executing group ' + groupid)
		os.mkdir(c.PARALLEL_STATS_DIR + '/' + groupid)
		
		for appid in groupmap[groupid]:
			u.loginfo('Executing app ' + runnable[appid])
			statfile = open(c.PARALLEL_STATS_DIR + '/' + groupid + '/' + str(appid) + '_' + timestamp + '.stat','a')
			statfile.write(runnable[appid])
			u.loginfo('perf stat ' + runnable[appid])
			status = subprocess.Popen('perf stat ' + runnable[appid], shell=True, stdout=statfile, stderr=statfile)
			app_statfile_list.append([status.pid, statfile])
		while True:
			if group_exec_completed(app_statfile_list):
				break
			else:
				u.loginfo('sleeping for jobs to finish')
				time.sleep(10)
				u.loginfo('woken up. checking if jobs are finished')
				

if __name__ == "__main__":
	c.LOGGER = 'parallel.log'
	main()
